#!/usr/bin/env perl

# martin, 2019-01-22, 2019-02-14, 2019-04-02, 2019-04-03
# call with --help for help/usage

# TODO:
# - coloured output
# - getting rid of Text::Table (maybe)
# - ask for time
# - favourite places (maybe)
# - display results in $PAGER

use strict;
use warnings;
use utf8;

no warnings qw[qw]; # Heh.

use Data::Dumper;
use Encode qw//;
use Module::Load qw//;

use Mojo::JSON;

my %urls = (
  base    => 'https://www.hvv.de',
  geofox  => 'https://geofox.hvv.de'
);

%urls = (
  %urls,
  home       => $urls{base}.'/en',
  gf_base    => $urls{geofox}.'/jsf/home.seam',
  check_name => $urls{geofox}.'/gti/restapp/checkName',
  get_route  => $urls{geofox}.'/gti/restapp/getRoute',

  # extended by get_auth_credentials
  script     => $urls{geofox}.'/jsf/'
);

sub print_logo {
  print <<'EOF';
              ________________________
             /  _  __ _    __ _    __
            / / / / /| |  / /| |  / /
           / / /_/ / | | / / | | / /
          / / __  /  | |/ /  | |/ /
_________/ /_/ /_/   |___/   |___/

EOF
}

sub print_help {
  Module::Load::load(File::Basename);

  my $basename = File::Basename::basename($0);
  print <<"EOF";
Usage: ./$basename [OPTION]...

Run without any option for interactive use.
Alternatively, run with some options for limited interactive use. :)

Run with at least -a and -b for non-interactive use.

Options:
  -a PLACE      use PLACE as start (from where?)
  -b PLACE      use PLACE as destination (where to?)

  -n NEXT       number of next schedules to fetch (default: 4)
  -p PREV       number of previous schedules to fetch (default: 0)

  -h, --help,
  -u, --usage   print help/usage information

Example:
  # prints 3 routes from Hamburg Airport to Elbphilharmonie
  ./$basename  -a "airport" -b "elphi" -n 1 -p 1

./$basename is (C) 2019 Martin Frederic 
EOF
}

sub print_mojo_error {
  print <<'EOF';
Looks as if Mojolicious is not installed (needed for HTTP requests).
Here is how you might install it:

Void Linux
  xbps-install perl-Mojolicious

Debian / Ubuntu
  apt install libmojolicious-perl

Fedora
  dnf install perl-Mojolicious

Arch Linux (AUR)
  yay -S perl-mojolicious
EOF
}

sub setup {
  binmode(STDIN,  'encoding(UTF-8)');
  binmode(STDOUT, 'encoding(UTF-8)');
  binmode(STDERR, 'encoding(UTF-8)');

  if ($^O =~ /MSWin32/) {
    print STDERR "Warning: This script might not work on MS-Windows.\n";

    # Get Unicode working in cmd.exe / PowerShell
    # (What the fucking fuck?)
    Module::Load::load(Win32::API);
    my $handler = Win32::API::More->new(
      qw[kernel32.dll SetConsoleOutputCP N N]
    );
    $handler->Call(65001);
  }

  $SIG{INT} = \&quit;
}

sub quit {
  my ($sig) = @_;

  print "\n";
  if ($^O =~ /MSWin32/) {
    print "See you, and don't forget to delete Windows!\n";
  } else {
    print "See you! ðŸ™ƒ\n";
  }
  exit(0);
}

sub prompt_user {
  no warnings qw[uninitialized];
  my ($label, $fail_msg) = @_;

  $fail_msg //= "Your input does not look valid\n";

  my $answer;
  while (1) {
    print "$label ";
    $answer = <STDIN>;
    chomp($answer);

    last if $answer ne '';
    print $fail_msg;
  }

  return $answer;
}

sub get_datetime {
  Module::Load::load(POSIX);

  my @dt = split(/ /, POSIX::strftime('%d.%m.%Y %H:%M', localtime));
  return (date => $dt[0], time => $dt[1]);
}

sub get_auth_credentials {
  # This method extracts the login details
  # from publicly accessible JavaScript --
  # Very legal & very cool!

  Module::Load::load(MIME::Base64);
  Module::Load::load(Digest::SHA);

  my ($ua) = @_;

  my ($res);

  # Extract main.js path
  $res = $ua->get($urls{gf_base})->result;
  unless ($res->is_success) {
    print "could not fetch geofox homepage\n";
    debug_response($res);
    die "^\n";
  }

  if ($res->body =~ m[(de/main.*?\.js)]) {
    $urls{script} .= $1;
  } else {
    die "could not extract main.js uri from geofox\n";
  }

  # Fetch main.js (contains credentials)
  $res = $ua->get($urls{script})->result;
  unless ($res->is_success) {
    print "could not fetch JavaScript\n";
    debug_response($res);
    die "^\n";
  }

  my $js = $res->body;
  my %auth;

  ($auth{username}) = $js =~ /gtiUser="(.*?)"/;
  ($auth{password}) = $js =~ /gtiPassword="(.*?)"/;

  unless ($auth{username} && $auth{password}) {
    die "could not extract login details\n";
  }

  return \%auth;
}

sub make_auth_headers {
  my ($ua, $auth, $url, $payload, $req_body);

  if (@_ == 3) {
    ($ua, $auth, $req_body) = @_;
  } else {
    ($ua, $auth, $url, $payload) = @_;
  }

  unless ($req_body) {
    # Create a dummy request body
    # which will be signed
    $req_body = $ua->build_tx(
      POST => $url,
      json => $payload
    )->req->body;

    # GEOFOX expects UTF-8
    $req_body = Encode::encode('UTF-8', $req_body);
  }

  # Reference, chapter 3.3.1:
  # https://geofox.hvv.de/gti/doc/pdf/GEOFOX_GTI_Anwenderhandbuch_p.pdf
  my $signature = MIME::Base64::encode_base64(
    Digest::SHA::hmac_sha1($req_body, $auth->{password}), '');

  return (
    'geofox-auth-user' => $auth->{username},
    'geofox-auth-signature' => $signature
  );
}

sub get_places {
  my ($ua, $auth, $query) = @_;

  my %payload = (
    maxList => 20,
    theName => {
      name => $query,
    }
  );

  my %headers = (
    'Accept'       => 'application/json',
    'Content-Type' => 'application/json',

    # geofox-auth-user, geofox-auth-signature
    make_auth_headers($ua, $auth, $urls{check_name}, \%payload)
  );

  my $res = $ua->post($urls{check_name}, \%headers,
                      json => \%payload)->result;
  unless ($res->is_success) {
    debug_response($res);
    die "^\n";
  }

  my $structure = Mojo::JSON::decode_json($res->body);
  unless ($structure->{returnCode} eq 'OK') {
    die "API did not return OK: ".Dumper($structure)."\n";
  }

  if (wantarray) {
    return $structure->{results}->@*;
  } else {
    return $structure->{results}[0];
  }
}

sub get_routes {
  my ($ua, $auth, %opts) = @_;

  $opts{from} // die "can't get route without 'from'\n";
  $opts{to}   // die "can't get route without 'to'\n";

  my %payload = (
    start => $opts{from},
    dest => $opts{to},
    intermediateStops => Mojo::JSON::false,
    language => 'en',
    penalties => [
      {
        name => 'desiredType',
        value => 'longdistancebus,fasttrain&extrafasttrain:10000'
      }
    ],
    realtime => 'REALTIME',
    returnContSearchData => Mojo::JSON::true,
    schedulesAfter  => ($opts{schedules_after}  // 4), # hvv.de defaults
    schedulesBefore => ($opts{schedules_before} // 0), # hvv.de defaults
    tariffInfoSelector => [
      {
        kinds => [1],
        tariff => 'HVV',
        tariffRegions => Mojo::JSON::false
      },
      {
        kinds => [1],
        tariff => 'SH',
        tariffRegions => Mojo::JSON::false
      }
    ],
    time => {
      # (date => foo, time => bar)
      get_datetime
    },
    timeIsDeparture => Mojo::JSON::true,
    toDestBy => 'FOOTPATH',
    toStartBy => 'FOOTPATH',
    version => 34
  );

  my $req_body = $ua->build_tx(
    POST => $urls{get_route},
    json => \%payload
  )->req->body;

  $req_body = Encode::encode('UTF-8', $req_body);

  my %headers = (
    'Accept'       => 'application/json',
    'Content-Type' => 'application/json',

    # geofox-auth-user, geofox-auth-signature
    make_auth_headers($ua, $auth, $req_body)
  );

  my $res = $ua->post(
    $urls{get_route},
    \%headers,
    $req_body
  )->result;
  unless ($res->is_success) {
    debug_response($res);
    die "^\n";
  }

  my $structure = $res->json;
  unless ($structure->{returnCode} eq 'OK') {
    die "Not OK: "
        .sprintf("(HTTP %d) ", $res->code)
        .Dumper($structure)."\n";
  }

  if (wantarray) {
    return $structure->{realtimeSchedules}->@*;
  } else {
    return $structure->{realtimeSchedules}[0];
  }
}

sub get_response {
  my ($ua, $url) = @_;

  my $res = $ua->get($url)->result;
  unless ($res->is_success) {
    p $res;
    exit(0);
  }
}

sub debug_cookies {
  my ($ua) = @_;

  unless ($ua->isa('Mojo::UserAgent')) {
    die 'debug_cookies expects Mojo::UserAgent';
  }

  my $cookies = $ua->cookie_jar->all;
  print Dumper($cookies);
}

sub debug_response {
  my ($res) = @_;

  unless ($res->isa('Mojo::Message::Response')) {
    die 'debug_response expects Mojo::Message::Response';
  }

  printf "Response: %d: %s\n", $res->code, $res->message;
  print $res->body, "\n";
}

sub display {
  Module::Load::load(Text::Table);

  my ($type, $ref) = @_;

  if ($type eq 'PlaceList') {
    my @places = $ref->@*;

    my $tb = Text::Table->new(qw/# Name City Type/);
    while (my ($index, $place) = each(@places)) {
      $tb->add($index, $place->{name},
               $place->{city}, $place->{type});
    }

    print "Found multiple places:\n\n";
    print $tb;

    printf "Please select a station [0-%d]: ", $#places;
    my $index = <STDIN>;
    chomp($index);

    return $places[$index];
  } elsif ($type eq 'RouteList') {
    my @routes = $ref->@*;

    for my $schedule (@routes) {
      my $tb = Text::Table->new(qw/Time Label/);
      my @connections = $schedule->{scheduleElements}->@*;
      while (my ($index, $connection) = each(@connections)) {
        $tb->add(
          $connection->{from}{depTime}{time},
          $connection->{from}{name}
        );
        $tb->add(
          undef,
          ($connection->{line}{direction} ?
           (sprintf "%s => %s",
            $connection->{line}{name},
            $connection->{line}{direction}) :
           "(@{[$connection->{line}{name}]})"
          )
        );

        if ($index == $#connections) {
          $tb->add(
            $connection->{to}{depTime}{time},
            $connection->{to}{name}
          );
        }
      }
      print $tb, "\n";
    }
  }
}

sub main {
  setup;
  print_logo;

  my (@places, $auth, %cmd_opts, %route_opts);

  if (@ARGV) {
    for (@ARGV) {
      if (/--?h(elp)?/)  { print_help; exit }
      if (/--?u(sage)?/) { print_help; exit }
    }

    Module::Load::load(Getopt::Std);

    # Switches:
    # a / b -- from A to B
    Getopt::Std::getopt('a:b:n:p:', \%cmd_opts);
  }

  # At this point, we're past the help/usage/whatever
  # section (which has to be displayed quickly) and
  # might load some modules dynamically
  eval    { Module::Load::load(Mojo::UserAgent) };
  if ($@) { print_mojo_error; exit }

  my $ua = Mojo::UserAgent->new;

  {
    local $| = 1;
    my $connect_msg = 'Establishing connection to HVV ...';
    print $connect_msg;
    $auth = get_auth_credentials($ua);
    print "\r", ' ' x length($connect_msg), "\r";
  }

  if ($cmd_opts{a}) {
    # non-interactive
    $route_opts{from} = get_places($ua, $auth, $cmd_opts{a});
  } else {
    # interactive
    @places = get_places($ua, $auth, prompt_user('From?'));
    $route_opts{from} = display(PlaceList => \@places);
    print "\n";
  }

  if ($cmd_opts{b}) {
    # non-interactive
    $route_opts{to} = get_places($ua, $auth, $cmd_opts{b});
  } else {
    # interactive
    @places = get_places($ua, $auth, prompt_user('To?'));
    $route_opts{to} = display(PlaceList => \@places);
    print "\n";
  }

  # check for definedness since
  # n can also contain a 0
  if (defined $cmd_opts{n}) {
    $route_opts{schedules_after} = $cmd_opts{n};
  }

  # dito
  if (defined $cmd_opts{p}) {
    $route_opts{schedules_before} = $cmd_opts{p};
  }

  printf("Here are the routes from %s to %s:\n\n",
         $route_opts{from}->{name},
         $route_opts{to}->{name});
  my @routes = get_routes($ua, $auth, %route_opts);
  display(RouteList => \@routes);
}

main;
